# 01 알고리즘이란?

알고리즘: 문제를 푸는 방법, 절차

	예시: 나이 맞추기
	A씨의 나이가 20이상 36미만인 경우 
	N = 16
	- 선형 탐색: 20살부터 25살까지 다물어보기: O(N)
	- 이진 탐색: 중간(28)미만 입니까? : (O(logN))

## DFS와 BFS
깊이 우선 탐색은 전체 탐색을 효율적으로 하기 위한 알고리즘이다. 깊이 우선 탐색은 동작을 수행하고 조건을 만족하지 않으면 이전의 단계로 돌아가서 다른 동작을 수행한다. 단순 무식한 탐색 알고리즘 이지만 탐색 순서(조건)에 따라 성능이 극적으로 차이가 생긴다.

응용
- 스도쿠 같은 퍼즐 해결
- 장기,체스와 같은 게임
- 탐색 결과를 메모하면서 실행하면 동적 계획법
- 위상 정렬(topology sort)

### BFS(Breadth-First Search, 너비 우선 탐색)
너비 우선 탐색은 이전 단계에 탐색 가능한 곳을 기록하고 현제 단계가 끝나면 이전 단계에서 기록한 탐색 가능한 곳을 탐색한다.

## 연습문제 
1. 20살이상 36살미만 나이 맞추기
```java
int HowOldAreYou(){
	int MAX = 36;
	int MIN = 20;

	while(true){
		int mid = (MAX + MIN) / 2;
		if(mid == age){
			break;
		}else if(age > mid){
			MIN = mid+1;
		} else {
			MAX = mid;
		}
	}
	return mid;
}
```

2. 0세~100세일 때 확실하게 맞출 수 있는 질문 횟수
	O(log(N))이니까 O(log_2(100))이 아닐까 6.67 이니까 7번인 듯
	
# 02 알고리즘 복잡도와 Big-O 표기법
계산 복잡도
- 구현하는 알고리즘을 실제로 프로그래밍하지 않아도 걸리는 시간을 대략적으로 파악할 수 있다.

Big-O 표기법은 시간에서 계수를 제외한 최고차항을 의미
이유: N이 커질수록 나머지의 비중은 줄어든다

문젠1. 여러 점들 중 최단 거리의 두 점 찾기
모든 점 계산: O(N^2)
중복되지 않게 모든 점 계산: O(N^2)
분할 정복법: O(NlogN)

## 복잡도
- 로그 복잡도에서 밑은 계수니까 생략해도 된다.
- 선형 복잡도: 다항식
- 지수 복잡도: N! 또는 지수승
- 상수시간: O(1)

## 시간 복잡도와 공간 복잡도
- 시간 복잡도: 계산 시간
- 공간 복잡도: 메모리 사용량

## 최악 시간 복잡도와 평균 시간 복잡도
데이터의 나열 상태에 따라서 계산 시간이 달라질 수있다.
- 최악 시간 복잡도: 최악의 경우
- 평균 시간 복잡도: 평균적인 경우

## 린다 우 빅오 표기법
빅오 표기법은 점근적 상한선으로 아무리 나쁜 상황이더라도 비교 함수보다 같거나 좋다.

### 오메가 표기법
- 빅오 표기법은 계산 시간 상한선을 평가하는 방법
- 오메가 표기법은 하한선을평가한다.
- 점근적 하한선으로 아무리 좋은 상황이더라도 비교 함수보다 같거나 나쁘다

### 세타 표기법
- 계산 시간이 상한과 하한이 상수배가 된다
- 점근적 상한과 하한의 교집합

# 03 설계기법 01 - 전체탐색
## 선형 탐색법
하나의 리스트에서 특정 값을 찾기위해서 인덱스 0부터 끝까지 다 돈다.

### 쌍 전체 탐색
> 두 리스트 a,b에서 각각 고른 값의 합이 K이상 중에서 최소값

```java
int min = Integer.MAX_VALUE;
for(int i = 0; i < a.length; i++){
	for(int j = 0; j < b.length; j++){
		int sum = a[i] + b[i];
		if(sum < K) continue;
		min = min < sum ? min : sum;
	}
}
```

## 조합 전체 탐색
> 리스트 a에서의 몇개의 값을 더했을 때 W보다 큰지 판별하라.

비트연산을 통해서 조합을 만들 수 있다. 범용적인 전체 탐색으로는 재귀함수가 있다.
```java
for(int bit = 0; bit < (1 << N); bit++){
	int sum = 0;
	for(int i = 0; i < N; i++){
		if(bit & (1 << i) > 0){
			sum += a[i];
		}
	}
	if(sum == W) break;
}
```

## 연습문제 
1. 인덱스 저장할 때 큰 값으로 업데이트
2. 리스트 돌면서 카운팅
3. 두번 째로 작은수를 구하는 O(N)
```java
int first = -INF;
int second = -INF;
for(int i = 0; i < a.length; i++){
	if(a[i] > first){
		second = first;
		first = a[i];
	} else if(a[i] > second){
		second = a[i];
	} 
}
```
4.  두 값의 차가 최대인 값을 구하는 O(N)
```java
int max = -INF;
int min = INF;
for(int i = 0; i < a.length; i++){
	if(a[i] > max) max = a[i];
	if(a[i] < min) min = a[i];
}
int answer = max - min > 0 ? max - min : min - max;
```
5. 정수 배열 a의 값이 모두 짝수고 2로 나눈 값으로 치환하는 작업을 더 이상 할 수 없을 때까지 반복한다. 이 작업을 몇번해야하는지
```java
for(int i = 0; i < a.length; i++){
	while(a[i] % 2 == ){
		a[i] /= 2;
	}
}
```
O(NlogN)
6. 0 <= X,Y,Z <= K를 만족하는 조합중에서 X+Y+Z=N을 만족하는 경우의 수를 O(N^2)로
```java
int count = 0;
for(int x = 0; x < N && x <= K; x++){
    for(int y = 0; y <= N; y++){
        int z = N - x - y;
        if(z > K) continue;
        if(x+y+z == N){
            count++;
        }
    }
}
```
7. 1이상 9이하의숫자로 이뤄진 길이 N의 문자열S 에서 숫자 사이에 +를 넣어 계산한 수의 총합 O(N2^N)
```java
for(int bit = 0; bit < (1 << N); bit++){
	int sum = 0;
	for(int i = 0; i < N; i++){
		if(bit & (1 << i) > 0){
			sum += (0~i까지)
		}
	}
}
```