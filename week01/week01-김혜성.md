# Chapter 1 알고리즘
### 알고리즘(algorithm)
- 문제를 푸는 방법, 절차
- e.g. 이진 탐색법(binary search method), 선형 탐색법(linear search method)
- 어떤 특정한 문제가 있을 때 그 어떠한 경우를 생각해도 '같은 방법으로' 답을 도출할 수 있다는 탁월한 특징이 있음
### 깊이 우선 탐색(depth-first search, DFS)
- 무작정 진행하는 동작을 막힐 때까지 반복하고, 막히면 한 단계 되돌아가서 다음 선택지를 시험하는 걸 반복하는 탐색 알고리즘
- 응용
    - 스도쿠, 장기
    - 탐색 결과를 메모하면 동적 계획법
    - 순서 관계를 정리하는 기법인 위상 정렬(topology sort)
    - 네트워크 흐름 알고리즘에서 서브 루틴으로 기능
### 너비 우선 탐색(breadth-first search, BFS)
- 출발점에서 가까운 곳부터 순서대로 탐색하는 탐색 알고리즘
- 목표를 달성하는 최소 절차를 알고 싶은 경우에 유용
### 매칭(matching)
- 두 카테고리 사이를 연결하는 문제를 풀기 위해 생각해낸 방법
## 연습 문제
### 1.2 나이 맞히기 게임에서 나이 후보가 0세 이상 100세 미만일 때 확실하게 맞출 수 있는 질문 횟수는?
7번 (log100)
### 1.3 그림 1-3 왼쪽 퍼즐의 답을 구하라.
(위쪽 왼쪽에서부터) 7, 3, 5, 1, 5, 8, 1, 9, 5
### 1.5 미로에서 각 칸 별로 이동 횟수를 알고 있는 상태일 때 실제 최단 경로를 복원하는 방법을 논하라.
도착지에서 부터 시작해서 이웃한 칸 중에서 이동 횟수가 (현재 칸의 이동 횟수 - 1)인 칸으로 이동하면서 도착지로 되돌아 가는 경로를 찾는다.

# Chapter 2 복잡도와 빅오 표기법
### 복잡도
- 실제로 알고리즘을 구현하지 않아도 계산 시간이 얼마나 걸릴지 어림짐작할 수 있는 '척도' 역할
### 빅오 표기법
- 란다우(Landau) O 표기법이라고도 함
- 알고리즘 A의 계산 시간 T(N)이 대략 P(N)에 비례하면 T(N) = O(P(N))이라 표현하고, 알고리즘 A의 복잡도는 O(P(N))이라 부름
- 어떤 알고리즘의 계산 시간이 T(N) = 3N^2 + 5N + 100이라면 복잡도는 최고차항에서 계수를 무시해 N^2이라고 함
### 복잡도 사용법
- 모든 데이터를 읽는 작업만 해도 O(N) 복잡도가 되므로 입력 데이터의 크기가 큰 문제를 다룰 때는 필요한 만큼만 데이터를 가져와서 처리하는 방식을 주로 사용
- 복잡도가 O(N!)이나 O(2^N)인 알고리즘은 `지수 시간(experimential time)`이 걸린다고 함
    - O(2^N)은 문제 크기가 작은 범위라면 충분히 쓸만 함
- 상수 d > 0이 존재하고 복잡도가 N^d 상수배로 상한이 제한되면 `다항 시간(polynomial time)`이 걸린다고 함
- NlogN과 N√N은 다항식 N^2이라는 상한이 정해지기 때문에 다항 시간이 필요한 계산량임
- O(1) 복잡도는 문제 크기에 의존하지 않는 상수 시간 이내에 처리가 끝나는 걸 의미하고 `상수 시간(constant time)`이 걸린다고 함
    - 경우에 따라 잘못된 자료형을 사용하면 계산량이 O(N)이 되어 해시 테이블을 사용하는 게 좋음
### 복잡도 관련 주의 사항
- `시간 복잡도(time complexity)`: 알고리즘 계산 시간에 대한 복잡도. 지금까지 논의한 복잡도가 이에 해당
- `공간 복잡도(space complexity)`: 알고리즘을 실행할 때 사용하는 메모리 사용량을 가리킴
- 최악 시간 복잡도: 최악의 경우에 해당하는 시간 복잡도. 단순히 복잡도라고 하면 이를 의미
- 평균 시간 복잡도: 입력 데이터 분포 상태를 가정한 경우의 시간 복잡도 기댓값
### 상세 설명
- 빅오 표기법은 점근적 상한선
- 오메가 표기법은 점근적 하한선
- 세타 표기법은 점근적 상한과 하하느이 교집합의 평균 범위 개념
## 연습 문제
### 2.1 입력 크기가 N일 때 란다우 빅오 표기법으로 나타내라.
T3(N) = 4N^2 + 3N√N → O(N^2)  
T4(N) = N√N + 5NlogN → O(N√N + NlogN)
### 2.6

# Chapter 3 전체 탐색
### 선형 탐색법(linear search method)
- 요소를 하나하나 순서대로 조사하는 탐색법
- 복잡도는 O(N)
- 응용
    - 조건을 만족하는 위치 파악 가능
    - 최솟값 구하기
### 쌍 전체 탐색
- e.g. 주어진 데이터 안에서 최적의 쌍을 탐색하는 문제, 주어진 두 쌍의 데이터에서 각각의 요소를 추출하는 방법을 최적화하는 문제
- 이중 for문을 사용하면 풀 수 있음
- 복잡도는 O(N^2)
    - 이진 탐색법을 사용하면 O(NlogN)으로 풀 수 있음
### 조합 전체 탐색
- 비트 연산
    - 복잡도는 O(N2^N)
- 재귀 함수(recursive function)
    - 동적 계획법과 깊이 관련
- 동적 계획법
    - 복잡도는 O(NW)
## 연습 문제
### 3.5
```
count = 0
found = false
while (true)
    for (a in array)
        if (a & (1 << count))
            found = true
            break
    if (found) break
    count++
```
# 면접 문제
### 6.4
삼각형에서 개미가 충돌하지 않는 경우는 모두 같은 방향으로 움직일 때 뿐이므로 (1 / 2)^3 * 2 = 1 / 2^2 = 1 / 4  
삼각형에서 충돌할 확률은 3 / 4  
n각형에서 충돌하지 않을 확률은 (1 / 2)^n * 2 = 1 / 2^(n - 1)  
따라서 n각형에서 충돌할 확률은 1 - 1 / 2^(n - 1)
### 6.5
5리터 물병에 물을 가득 채운 후 이 물병의 물로 3리터 물병을 가득 채우면 5리터 물병에 2리터만 남는다.  
5리터 물병의 2리터를 빈 3리터 물병으로 옮기고 5리터 물병을 가득 채운다.  
5리터 물병의 물로 2리터가 채워진 3리터 물병을 가득 채우면 1리터만 옮겨지므로 5리터 물병에 4리터가 남게 된다.
